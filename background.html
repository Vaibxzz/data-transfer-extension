<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kosh Scraper — Last Scrape</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; padding:18px;max-width:980px;margin:auto}
    h1{font-size:18px;margin-bottom:6px}
    pre{background:#f6f8fa;padding:12px;border-radius:6px;overflow:auto}
    table{border-collapse:collapse;width:100%;margin-top:12px}
    th,td{border:1px solid #ddd;padding:8px;text-align:left}
    .controls{margin:12px 0}
    button{padding:8px 12px;margin-right:8px}
    .meta{color:#666;font-size:13px}
  </style>
</head>
<body>
  <h1>Kosh — Scraper UI</h1>
  <div class="meta">Trigger scraping of the active tab (table detection is flexible: it finds the first table).</div>

  <div class="controls">
    <button id="btn-scrape">Scrape active tab now</button>
    <button id="btn-refresh">Refresh displayed result</button>
    <button id="btn-download-json">Download JSON</button>
    <button id="btn-download-csv">Download CSV</button>
  </div>

  <div id="status" class="meta">No results yet.</div>

  <div id="result-area">
    <h3>Preview</h3>
    <div id="preview"></div>
  </div>

  <script>
    // UI helpers
    const btnScrape = document.getElementById('btn-scrape');
    const btnRefresh = document.getElementById('btn-refresh');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');
    const btnJson = document.getElementById('btn-download-json');
    const btnCsv = document.getElementById('btn-download-csv');

    function showStatus(txt, isError) {
      statusEl.textContent = txt;
      statusEl.style.color = isError ? 'crimson' : '#444';
    }

    async function fetchStored() {
      return new Promise(resolve => {
        chrome.storage.local.get('lastScrape', items => {
          resolve(items.lastScrape || null);
        });
      });
    }

    function renderResult(payload) {
      if (!payload) {
        preview.innerHTML = '<em>No scrape result stored yet</em>';
        showStatus('No result stored');
        return;
      }
      const { fetchedAt, result } = payload;
      if (!result) {
        preview.innerHTML = `<pre>Invalid result</pre>`;
        showStatus('Invalid stored result', true);
        return;
      }
      if (!result.ok) {
        preview.innerHTML = `<pre>Error: ${result.error || 'Unknown'}</pre>`;
        showStatus('Scrape error: ' + (result.error || 'Unknown'), true);
        return;
      }

      showStatus(`Last scraped: ${fetchedAt} — rows: ${result.rowCount || 0}`);

      // build an HTML table preview (first 20 rows)
      const rows = result.rows || [];
      const headers = result.headers && result.headers.length ? result.headers : (rows.length ? Object.keys(rows[0]) : []);
      let html = '';
      if (headers.length) {
        html += '<table><thead><tr>' + headers.map(h => `<th>${escapeHtml(h)}</th>`).join('') + '</tr></thead><tbody>';
        for (let i = 0; i < Math.min(rows.length, 50); i++) {
          const r = rows[i];
          html += '<tr>' + headers.map(h => `<td>${escapeHtml((r[h] || '').toString())}</td>`).join('') + '</tr>';
        }
        html += '</tbody></table>';
      } else {
        html = '<pre>' + escapeHtml(JSON.stringify(result, null, 2)) + '</pre>';
      }
      preview.innerHTML = html;
    }

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]);
    }

    async function triggerScrape() {
      showStatus('Scraping active tab...');
      // message background to scrape
      const resp = await new Promise(resolve => {
        chrome.runtime.sendMessage({ type: 'SCRAPE_NOW' }, r => resolve(r));
        // note: background calls sendResponse asynchronously
      });
      if (!resp) {
        showStatus('No response from background script', true);
        return;
      }
      if (!resp.ok) {
        showStatus('Scrape failed: ' + (resp.error || 'unknown'), true);
        return;
      }
      // refresh display using storage
      const payload = resp.payload || await fetchStored();
      renderResult(payload);
    }

    async function refresh() {
      const payload = await fetchStored();
      renderResult(payload);
    }

    function download(filename, content) {
      const blob = new Blob([content], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    btnScrape.addEventListener('click', triggerScrape);
    btnRefresh.addEventListener('click', refresh);

    btnJson.addEventListener('click', async () => {
      const payload = await fetchStored();
      if (!payload) { showStatus('No stored result', true); return; }
      download('kosh-scrape.json', JSON.stringify(payload, null, 2));
    });

    btnCsv.addEventListener('click', async () => {
      const payload = await fetchStored();
      if (!payload || !payload.result || !payload.result.rows) { showStatus('No rows to export', true); return; }
      const rows = payload.result.rows;
      const headers = payload.result.headers && payload.result.headers.length ? payload.result.headers : Object.keys(rows[0] || {});
      const lines = [headers.join(',')];
      for (const r of rows) {
        const line = headers.map(h => {
          const v = (r[h] || '').toString().replace(/"/g, '""');
          return `"${v}"`;
        }).join(',');
        lines.push(line);
      }
      download('kosh-scrape.csv', lines.join('\n'));
    });

    // Listen for runtime notifications from background
    chrome.runtime.onMessage.addListener((msg) => {
      if (msg && msg.type === 'SCRAPE_COMPLETE') {
        renderResult(msg.payload);
      }
    });

    // initial render
    refresh();
  </script>
</body>
</html>